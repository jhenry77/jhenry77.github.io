<!DOCTYPE html>  
<html>  
<head>  
<style>  
canvas {  
    border: 1px solid #d3d3d3;  
    background-color: #f1f1f1;  
}  
</style>  
</head>  
<body>  
<script>  

// Game setup
let canvas = document.createElement('canvas');
let ctx = canvas.getContext('2d');
document.body.appendChild(canvas);

// Set canvas dimensions
canvas.width = 800;
canvas.height = 600;

// Vector Class
class Vector {
  constructor(x = 0, y = 0) {
    this.x = x;
    this.y = y;
  }

  add(v) {
    this.x += v.x;
    this.y += v.y;
  }

  scale(scalar) {
    this.x *= scalar;
    this.y *= scalar;
  }

  normalize() {
    let length = Math.sqrt(this.x * this.x + this.y * this.y);
    if (length > 0) {
      this.x /= length;
      this.y /= length;
    }
  }
}



// Game variables
let isRunning = true;
let player = { position: new Vector(100,500), 
    width: 50, 
    height: 50, 
    speed: 100, 
    direction: new Vector(0,0)};
let lastTime = performance.now();


// Event listener for stopping the game
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    isRunning = false;
  }
});

// Game loop
function gameLoop(timestamp) {
  if (!isRunning){
    return
  }; // Exit the loop if the game stops

  // Update game state
  let deltaTime = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  update(deltaTime);
  
  // Render the game
  draw();

  // Loop
   requestAnimationFrame(gameLoop);
}
//Listens for specific user input
function getInput(){
    if (keys.ArrowLeft){ 
        player.direction.x = -1
    }else if (keys.ArrowRight){
        player.direction.x = 1
    }else{
        player.direction.x = 0;
    }

    if(keys.ArrowDown){ 
        player.direction.y = 1
    }else if(keys.ArrowUp){ 
        player.direction.y = -1
    }else{
        player.direction.y = 0;
    }


}
// Update game state such as player position
function update(deltaTime) {
    //Gets user input
    getInput();

    // Normalizing the vector to keep diagonal values consistent
    player.direction.normalize();

    // Scales the direction by our variable speed and the amount of time that has passed, and then adds that to the player direction
    player.direction.scale(player.speed);
    player.direction.scale(deltaTime);
    player.position.add(player.direction);
    
    
    // Old Code


    // if (keys.ArrowLeft && player.x > 0){ 
    //     player.x -= player.speed * deltaTime;
    // }
    // if (keys.ArrowRight && player.x + player.width < canvas.width){ 
    //     player.x += player.speed * deltaTime;
    // }
    // if(keys.ArrowDown && player.y + player.height < canvas.height){ 
    //     player.y += player.speed * deltaTime;
    // }
    // if(keys.ArrowUp && player.y  >0){ 
    //     player.y -= player.speed * deltaTime;
    // }

}

// Draw the game
function draw() {
  // Clear the canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw player
  ctx.fillStyle = 'blue';
  ctx.fillRect(player.position.x, player.position.y, player.width, player.height);
}

// Track keyboard input
let keys = {};
window.addEventListener('keydown', (e) => keys[e.key] = true);
window.addEventListener('keyup', (e) => keys[e.key] = false);

// Start the game loop
requestAnimationFrame(gameLoop)


  
</script>  
  
<p>This is our gaming area</p>  
  
</body>  
</html>  